GAMS 30.3.0  rc5da09e Released Mar  6, 2020 WEX-WEI x86 64bit/MS Windows - 01/18/22 18:30:34 Page 1
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
C o m p i l a t i o n


   1  Sets
   2  all_t       all hours               /1*16/
   3  t(all_t)    hours                   /1*16/
   4  tec         generators              /base, peak, wind, solar/
   5  con(tec)    conventional generation /base, peak/
   6  all_n       all buses               /north, south/
   7  n(all_n)    selected buses          /north, south/
   8  ;
   9   
  10   
  11  alias (n,m);
  12  alias (all_n,all_m);
  13   
  14  * parameters for supply and demand functions
  15  Parameter elasticity / -0.25 /;
  16  Parameter p_ref / 65 /;
  17  Parameter specific_network_costs /200/;
  18  Parameter capacity_slope / 0.5 /;
  19  *Source for network costs: EMMA (3400 EUR/MW/km discontiert mit i = 0.07 ueber 40 Jahre)
  20   
  21  Table B(all_n,all_m)        Susceptance of transmission lines
  22           north  south
  23  north        1     700
  24  south      700       1
  25  ;
  26   
  27  Parameters
  28  * Input Parameters
  29  i_cost(*,*)                 cost data to be loaded from sheet "cost"
  30  i_load(all_t,all_n)         load data to be loaded from sheet "time series" in MWh
  31  i_avail(all_t,tec,all_n)    availability data
  32   
  33  * Model Parameters
  34  load_ref(t,n)               hourly load in GWh
  35  avail(t,tec,n)              availability of wind and solar generation (1)
  36  c_var(tec,n)                variable costs (EUR per MWh)
  37  c_fix(tec,n)                annualized fixed costs (EUR per MW p.a.)
  38  cap_lim(tec,n)              capacity limit of generation in each node
  39  grid_cost(n,m)
  40  sc                          scaling factor
  41  a_nodal(t,n)                intercept of inverse nodal demand function
  42  s_nodal(t,n)                slope of inverse nodal demand function
  43   
  44  A_zonal(t)                  intercept of inverse zonal demand function
  45  S_zonal(t)                  slope of inverse zonal demand function
  46   
  47  * Output Parameters
  48  welfare
  49  consumer_surplus
  50  generation_costs
  51  network_cost
  52  network_cost_1
  53  network_cost_2
  54  network_cost_3
  55   
  56  res_share
  57  real_generation(t,tec,n)
  58  load_deviation(t,n)
  59  load_shedding(t,n)
  60   
  61  o_RES_share
  62  o_load(t,n)
  63  o_cap(tec,n)
  64  o_gen(t,tec,n)
  65  price(t)
  66  o_instrument
  67  ;
  68   
  69  * Load data
GDXIN   C:\Users\a.eicke\Documents\Locational-investment-signals\Three node models\in.gdx
--- LOAD  i_cost = 1:i_cost
--- LOAD  i_load = 2:i_load
**** Unique domain errors for symbol i_load
**** Only the first 10 errors are shown
 Dim  Elements
   1  17, 18, 19, 20, 21, 22, 23, 24, 25, 26

--- LOAD  i_avail = 3:i_avail
  71  $LOADdc i_cost, i_load, i_avail
****                       $649
**** 649  Domain violation when loading from GDX file
  72   
  73  * Data assignment
  74  sc = card(t) / 8760;
  75  load_ref(t,n)               = i_load(t,n) / 1000;
  76  avail(t,tec,n)              = i_avail(t,tec,n);
  77  avail(t,con,n)              = 1;
  78  c_var(tec, n)               = i_cost(tec,"cost_var");
  79  c_fix(tec, n)               = round(i_cost(tec,"cost_fix") * 1000 * sc);
  80  cap_lim(tec,n)              = 100;
  81  grid_cost(n,m)              = round(B(n,m) * specific_network_costs * sc);
  82   
  83  *Inverse demand function at each node
  84  a_nodal(t,n)                = p_ref *(1-1/elasticity);
  85  s_nodal(t,n)                = p_ref *(1/(elasticity*load_ref(t,n)));
  86   
  87  * Inverse demand function of the zonal market (only holds if P(t) < a_nodal(t,n) for all t,n)
  88  A_zonal(t)                  = sum(n, a_nodal(t,n) / s_nodal(t,n)) / sum(n, 1/ s_nodal(t,n));
  89  S_zonal(t)                  = 1 / sum(n, 1/ s_nodal(t,n));
  90   
  91  display c_var, load_ref, avail, c_fix, a_nodal, s_nodal, A_zonal, S_zonal;
  92   
  93  Binary variables y1(t,tec,n),y2(t,tec,n),y3(tec,n),y4(tec,n),y5(t),y6(t);
  94   
  95  Parameter M1 / 100000/;
  96  Parameter M2 / 100000/;
  97  Parameter M3 / 100000/;
  98  Parameter M4 / 100000/;
  99  Parameter M5 / 100000/;
 100  Parameter M6 / 100000/;
 101   
 102  Free Variables
 103  GEN(t,tec,n)
 104  CAP(tec,n)
 105  WF
 106  FLOW(t,n,m)
 107  INSTRUMENT
 108  THETA(t,n)
 109  SPOT_PRICE(t)
 110  ;
 111   
 112  Positive variables
 113  mu_G_min(t,tec,n)
 114  mu_G_max(t,tec,n)
 115  mu_C_min(tec,n)
 116  mu_C_max(tec,n)
 117  mu_D_min(t)
 118   
 119  GRID_CAP(n,m)
 120  LOAD_redi(t,n)
 121  LOAD_spot(t)
 122  UP(t,tec,n)
 123  DOWN(t,tec,n)
 124  ;
 125   
 126  Equations
 127  objective, instr_const,
 128  nodal_energy_balance,
 129  grid_eq1, grid_eq2, grid_eq3, grid_eq4,
 130  redispatch1, redispatch2,
 131   
 132  gen_min, gen_max,
 133  cap_min, cap_max,
 134  demand_min,
 135  energy_balance,
 136   
 137  KKT_GEN, KKT_CAP, KKT_load,
 138   
 139  complementarity1a,
 140  complementarity1b,
 141  complementarity2a,
 142  complementarity2b,
 143  complementarity3a,
 144  complementarity3b,
 145  complementarity4a,
 146  complementarity4b,
 147  complementarity5a,
 148  complementarity5b,
 149  complementarity6a,
 150  complementarity6b
 151  ;
 152   
 153  objective..                     WF =e= sum((t,n), a_nodal(t,n) * LOAD_redi(t,n) + 1/2 * s_nodal(t,n) * LOAD_redi(t,n) * LOAD_redi(t,n))
 154                                      - sum((tec,n), CAP(tec,n) * c_fix(tec,n) + 0.5 * CAP(tec,n) * CAP(tec,n) * capacity_slope)
 155                                      - sum((t,tec,n), GEN(t,tec,n) * c_var(tec,n))
 156                                      - sum((t,tec,n), (UP(t,tec,n) - DOWN(t,tec,n)) * (c_var(tec,n)))
 157                                      - sum((n,m),(GRID_CAP(n,m) * grid_cost(n,m)) / 2)
 158                                      ;
 159   
 160  nodal_energy_balance(t,n)..     sum(tec,GEN(t,tec,n) - DOWN(t,tec,n) + UP(t,tec,n)) - LOAD_redi(t,n) =E= sum(m,FLOW(t,n,m));
 161   
 162  *network constraints
 163  grid_eq1(t,n,m)..               FLOW(t,n,m) =l= GRID_CAP(n,m);
 164  grid_eq2(n,m)..                 GRID_CAP(n,m) =e= GRID_CAP(m,n);
 165  grid_eq3(t,n,m)..               FLOW(t,n,m) =e= B(n,m) *(THETA(t,n) - THETA(t,m));
 166  grid_eq4(t,n)..                 THETA(t,'south') =e= 0;
 167   
 168  redispatch1(t,tec,n)..          DOWN(t,tec,n) =L= GEN(t,tec,n);
 169  redispatch2(t,tec,n)..          UP(t,tec,n) =L= CAP(tec,n) * avail(t,tec,n) - GEN(t,tec,n);
 170   
 171  ** INNER PROBLEM
 172  gen_min(t,tec,n)..              0 =g= -GEN(t,tec,n);
 173  gen_max(t,tec,n)..              0 =g= GEN(t,tec,n) - CAP(tec,n) * avail(t,tec,n);
 174   
 175  cap_min(tec,n)..                0 =g= -CAP(tec,n);
 176  cap_max(tec,n)..                0 =g= CAP(tec,n) - cap_lim(tec,n);
 177   
 178  demand_min(t)..                 0 =g= -LOAD_spot(t);
 179  energy_balance(t)..             0 =e= sum((tec,n),GEN(t,tec,n)) - LOAD_spot(t);
 180   
 181  KKT_GEN(t,tec,n)..              c_var(tec,n) + mu_G_max(t,tec,n) - mu_G_min(t,tec,n) - SPOT_PRICE(t) =e= 0;
 182  KKT_CAP(tec,n)..                c_fix(tec,n) + capacity_slope * CAP(tec,n) + INSTRUMENT - sum(t,avail(t,tec,n) * mu_G_max(t,tec,n)) + mu_C_max(tec,n) - mu_C_min(tec,n) =e= 0;
 183  KKT_load(t)..                   -(A_zonal(t) + S_zonal(t) * LOAD_spot(t)) - mu_D_min(t) + SPOT_PRICE(t) =e= 0;
 184   
 185  complementarity1a(t,tec,n)..    GEN(t,tec,n)        =L= y1(t,tec,n) * M1;
 186  complementarity1b(t,tec,n)..    mu_G_min(t,tec,n)   =L= (1-y1(t,tec,n)) * M1;
 187  complementarity2a(t,tec,n)..    CAP(tec,n) * avail(t,tec,n) - GEN(t,tec,n) =L= y2(t,tec,n) * M2;
 188  complementarity2b(t,tec,n)..    mu_G_max(t,tec,n)   =L= (1-y2(t,tec,n)) * M2;
 189  complementarity3a(tec,n)..      CAP(tec,n)          =L= y3(tec,n) * M3;
 190  complementarity3b(tec,n)..      mu_C_min(tec,n)     =L= (1-y3(tec,n)) * M3;
 191  complementarity4a(tec,n)..      cap_lim(tec,n) - CAP(tec,n) =L= y4(tec,n) * M4;
 192  complementarity4b(tec,n)..      mu_C_max(tec,n)     =L= (1-y4(tec,n)) * M4;
 193  complementarity5a(t)..          LOAD_spot(t)        =L= y5(t) * M5;
 194  complementarity5b(t)..          mu_D_min(t)       =L= (1-y5(t)) * M5;
 195  complementarity6a(t)..          LOAD_spot(t) - sum((tec,n),GEN(t,tec,n)) =L= y6(t) * M6;
 196  complementarity6b(t)..          SPOT_PRICE(t)           =L= (1-y6(t)) * M6;
 197   
 198   
 199  Model LOCI /
 200   
 201  objective
 202  nodal_energy_balance
 203   
 204  grid_eq1
 205  grid_eq2
 206  grid_eq3
 207  grid_eq4
 208   
 209  redispatch1
 210  redispatch2
 211   
 212  gen_min
 213  gen_max
 214  cap_min
 215  cap_max
 216   
 217  demand_min
 218  energy_balance
 219   
 220  KKT_GEN
 221  KKT_CAP
 222  KKT_load
 223   
 224  complementarity1a
 225  complementarity1b
 226  complementarity2a
 227  complementarity2b
 228  complementarity3a
 229  complementarity3b
 230  complementarity4a
 231  complementarity4b
 232  complementarity5a
 233  complementarity5b
 234  complementarity6a
 235  complementarity6b
 236  /;
 237   
 238   
 239  INSTRUMENT.lo = -10;
 240  INSTRUMENT.up = 10;
 241   
 242  GEN.up(t,tec,n) = 100;
 243  GEN.lo(t,tec,n) = 0;
 244   
 245  DOWN.up(t,tec,n) = 100;
 246  DOWN.lo(t,tec,n) = 0;
 247   
 248  UP.up(t,tec,n) = 100;
 249  UP.lo(t,tec,n) = 0;
 250   
 251  LOCI.nodlim = 80000000;
 252  LOCI.resLim = 150000;
 253   
 254  * default value is too large (tested by comparing results to a nodal model with network costs = 0)
 255  Option optcr = 0.0005;
 256   
 257  Option MIQCP = Cplex;
 258   
 259   
 260  Solve LOCI maximizing WF using MIQCP;
****                                      $257
**** 257  Solve statement not checked because of previous errors
 261   
 262  price(t) = SPOT_PRICE.L(t);
****                        $141
**** 141  Symbol declared but no values have been assigned. Check for missing
****         data definition, assignment, data loading or implicit assignment
****         via a solve statement.
****         A wild shot: You may have spurious commas in the explanatory
****         text of a declaration. Check symbol reference list.
 263   
 264  o_instrument = INSTRUMENT.L / sc / 1000;
 265   
 266  network_cost_1 = sum((n,m),(GRID_CAP.L(n,m) / 2 * grid_cost(n,m)));
****                                       $141
**** 141  Symbol declared but no values have been assigned. Check for missing
****         data definition, assignment, data loading or implicit assignment
****         via a solve statement.
****         A wild shot: You may have spurious commas in the explanatory
****         text of a declaration. Check symbol reference list.
 267  network_cost_2 = sum((t,tec,n), (UP.L(t,tec,n) - DOWN.L(t,tec,n)) * c_var(tec,n));
 268  network_cost_3 = sum((t), A_zonal(t) * LOAD_spot.L(t) + 1/2 * S_zonal(t) * LOAD_spot.L(t) * LOAD_spot.L(t))
****                                                   $141
**** 141  Symbol declared but no values have been assigned. Check for missing
****         data definition, assignment, data loading or implicit assignment
****         via a solve statement.
****         A wild shot: You may have spurious commas in the explanatory
****         text of a declaration. Check symbol reference list.
 269                  - sum((t), A_zonal(t) * sum(n, LOAD_redi.L(t,n)) + 1/2 * S_zonal(t) * sum(n, LOAD_redi.L(t,n)) * sum(n, LOAD_redi.L(t,n)))
****                                                           $141
**** 141  Symbol declared but no values have been assigned. Check for missing
****         data definition, assignment, data loading or implicit assignment
****         via a solve statement.
****         A wild shot: You may have spurious commas in the explanatory
****         text of a declaration. Check symbol reference list.
 270                  ;
 271   
 272  network_cost = network_cost_1 + network_cost_2 + network_cost_3;
 273   
 274  consumer_surplus = sum((t), A_zonal(t) * LOAD_spot.L(t) + 1/2 * S_zonal(t) * LOAD_spot.L(t) * LOAD_spot.L(t));
 275   
 276  generation_costs = (sum((tec,n), CAP.L(tec,n) * c_fix(tec,n) + 0.5 * CAP.L(tec,n) * CAP.L(tec,n) * capacity_slope) + sum((t,tec,n), GEN.L(t,tec,n) * c_var(tec,n)));
****                                       $141
**** 141  Symbol declared but no values have been assigned. Check for missing
****         data definition, assignment, data loading or implicit assignment
****         via a solve statement.
****         A wild shot: You may have spurious commas in the explanatory
****         text of a declaration. Check symbol reference list.
 277   
 278  *sum_instrument = sum((tec,n), INSTRUMENT.L(tec,n) * CAP.L(tec,n));
 279   
 280  load_deviation(t,n) = ((SPOT_PRICE.L(t) - a_nodal(t,n)) / s_nodal(t,n)) - load_ref(t,n);
 281  load_shedding(t,n) = LOAD_spot.L(t) - LOAD_redi.L(t,n);
 282  res_share = 1 - sum((t,con,n), GEN.L(t,con,n)) / sum((t,tec,n), GEN.L(t,tec,n));
 283  o_cap(tec,n) = CAP.L(tec,n);
 284  o_gen(t,tec,n) = GEN.L(t,tec,n);
 285  real_generation(t,tec,n) = GEN.L(t,tec,n) + UP.L(t,tec,n) - DOWN.L(t,tec,n);
 286  welfare = WF.L;
****               $141
**** 141  Symbol declared but no values have been assigned. Check for missing
****         data definition, assignment, data loading or implicit assignment
****         via a solve statement.
****         A wild shot: You may have spurious commas in the explanatory
****         text of a declaration. Check symbol reference list.
 287   
 288  Display WF.L, consumer_surplus, generation_costs, network_cost, network_cost_1, network_cost_2, network_cost_3, CAP.L, GEN.L, UP.L, DOWN.L, FLOW.L, price, load_deviation, load_shedding, GRID_CAP.L, LOAD_redi.L, LOAD_spot.L, o_instrument;
****                                                                                                                                                   $141
**** 141  Symbol declared but no values have been assigned. Check for missing
****         data definition, assignment, data loading or implicit assignment
****         via a solve statement.
****         A wild shot: You may have spurious commas in the explanatory
****         text of a declaration. Check symbol reference list.
 289   
 290  execute_UNLOAD 'Output/without_instrument.gdx' welfare, consumer_surplus, generation_costs, res_share, o_instrument, o_cap, o_gen, price, c_fix;

**** LIST OF STRAY NAMES - CHECK DECLARATIONS FOR SPURIOUS COMMAS
**** STRAY NAME instr_const OF TYPE EQU  

**** 9 ERROR(S)   0 WARNING(S)
GAMS 30.3.0  rc5da09e Released Mar  6, 2020 WEX-WEI x86 64bit/MS Windows - 01/18/22 18:30:34 Page 2
G e n e r a l   A l g e b r a i c   M o d e l i n g   S y s t e m
Include File Summary


   SEQ   GLOBAL TYPE      PARENT   LOCAL  FILENAME

     1        1 INPUT          0       0  C:\Users\a.eicke\Documents\Locational-investment-signals\Three node models\without_instrument.gms
     2       70 GDXIN          1      70  C:\Users\a.eicke\Documents\Locational-investment-signals\Three node models\in.gdx


COMPILATION TIME     =        0.015 SECONDS      3 MB  30.3.0 rc5da09e WEX-WEI


USER: Small MUD - 5 User License                     S190305:0326AO-WIN
      Hertie School of Governance GmbH, Governance of DigitalizaDC14808
      License for teaching and research at degree granting institutions


**** FILE SUMMARY

Input      C:\Users\a.eicke\Documents\Locational-investment-signals\Three node models\without_instrument.gms
Output     C:\Users\a.eicke\Documents\Locational-investment-signals\Three node models\without_instrument.lst

**** USER ERROR(S) ENCOUNTERED
